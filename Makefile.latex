#
#           Common Makefile for LaTeX documents
#
# Copyright (C) 2013, 2014, 2015 Chris Cummins.
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#
# Ensure that any Makefile which includes this defines the $(Document)
# variable. The variable must be the name of the target LaTeX source
# file without the file extension. For example, to build a document
# myreport.tex into myreport.pdf:
#
#     Document = doc
#

#------------------------------------------------------------------------
# Build configuration.
#------------------------------------------------------------------------

# The system-wide LaTeX library name.
BIBLIBRARY = library

# Additional flags to pass to $(PDFLATEX).
CFLAGS = 				\
	-recorder			\
	-output-format pdf 		\
	-progname pdflatex 		\
	-file-line-error 		\
	-interaction=nonstopmode	\
	$(NULL)


#------------------------------------------------------------------------
# End of build configuration.
#------------------------------------------------------------------------
DocumentPDF = $(Document).pdf
DocumentTex = $(Document).tex
DocumentAux = $(Document).aux
DocumentBuildLog = make.log
DocumentBibfile = refs.bib

# Phony targets.
PhonyTargets =
.PHONY: $(PhonyTargets)

# The full list of input files read by pdflatex. This is grabbed from
# the .fls that is generated by pdflatex. As a result, if we haven't
# run pdflatex before, there will be no .fls file, so we just return
# the $(DocumentTex) file.
DocumentDependencies    = \
	$(shell test -f $(Document).fls				\
		&& $(EGREP) '^INPUT ' $(Document).fls		\
		| $(AWK) ' !x[$$0]++' | $(SED) 's/^INPUT //'	\
		|| echo $(DocumentTex))
# The full list of input .tex files read by pdflatex.
DocumentTexDependencies = $(filter %.tex,$(DocumentDependencies))
# The list of .tex files which are local to this project, i.e. don't
# contain absolute paths.
DocumentSources         = $(filter-out /%,$(DocumentTexDependencies))

# Import lib/*.sty libraries.
export TEXINPUTS := .:./lib:$(TEXINPUTS)

MOSTLYCLEANFILES =			\
	$(DocumentPDF)			\
	$(Document).fls			\
	$(DocumentBuildLog)		\
	*-blx.bib			\
	*.acn 				\
	*.acr 				\
	*.alg 				\
	*.aux 				\
	*.bbl 				\
	*.bcf 				\
	*.blg 				\
	*.dvi 				\
	*.fdb_latexmk 			\
	*.glg 				\
	*.glo 				\
	*.gls 				\
	*.idx 				\
	*.ilg 				\
	*.ind 				\
	*.ist 				\
	*.lof 				\
	*.log 				\
	*.lol 				\
	*.lot 				\
	*.maf 				\
	*.mtc 				\
	*.mtc0 				\
	*.nav 				\
	*.nlo 				\
	*.out 				\
	*.pdfsync 			\
	*.ps 				\
	*.run.xml 			\
	*.snm 				\
	*.synctex.gz			\
	*.tdo 				\
	*.toc 				\
	*.vrb 				\
	*.xdy 				\
	$(NULL)

#------------------------------------------------------------------------
# Build targets.
#------------------------------------------------------------------------
doc_DATA = $(DocumentPDF)

#
# Viewing PDF documents
#
if HAVE_PDF_VIEWER
PhonyTargets += open
open:
	$(AM_V_at)if [ -f $(DocumentPDF) ]; then				\
		$(PDF_VIEWER) $(DocumentPDF) >/dev/null 2>&1 &		\
	else								\
		$(MAKE) $(DocumentPDF);					\
		$(MAKE) $@;						\
	fi
endif

#
# Building word counts.
#
if HAVE_TEXCOUNT
PhonyTargets += wc
wc: $(Document).wc
	$(AM_V_at)$(SED) '1,/total/Id' < $<				\
		| $(EGREP) --color=never '^(Words|Number)'

# Generate a word count file.
#
# If there is a compiled .pdf file, then use the $(TEXCOUNT) script to
# generate a .wc file. If the .pdf file hasn't been built yet, then
# invoke make to generate it before recursing.
$(Document).wc: $(DocumentSources)
	$(AM_V_at)if [ -f $(DocumentPDF) ]; then				\
		$(TEXCOUNT) $(DocumentSources) > $(Document).wc; 	\
	else								\
		$(MAKE) $(DocumentPDF);					\
		$(MAKE) $@;						\
	fi

MOSTLYCLEANFILES += $(Document).wc
endif

#
# Citation use checker.
#
if HAVE_CHECKCITES
PhonyTargets += cite
cite: $(Document).cite
	$(AM_V_at)cat $<

# Generate a citation check file.
MOSTLYCLEANFILES += $(Document).cite
$(Document).cite: $(DocumentSources)
	$(AM_V_at)if [ -f $(DocumentPDF) ]; then			\
		$(CHECKCITES) --undefined $(DocumentAux) > $@;		\
	else								\
		$(MAKE) $(DocumentPDF);					\
		$(MAKE) $@;						\
	fi
endif

if HAVE_TEXTLINT
#
# Writing style checker.
#
PhonyTargets += style lint
# The process for caching the result of textlint is a little bit more
# complicated than the "wc" or "cite" rules. Since textlint is a slow
# process to run, we invoke it while using the "tee" command in order
# to simultaneously print the results to stdout while caching them for
# future retrieval. As a result, a use the file .$(Document).lint to
# indicate whether we have just generated the files, so that cache-hit
# rule doesn't print the cached results that we've just generated.
style lint: $(Document).lint
	$(AM_V_at)if [ ! -f .$(Document).lint ]; then			\
		cat $(Document).lint;					\
	fi
	$(AM_V_at)$(RM) .$(Document).lint

# Run textlint and cache results.
MOSTLYCLEANFILES += $(Document).lint .$(Document).lint
$(Document).lint: $(DocumentSources)
	$(AM_V_at)if [ -f $(DocumentPDF) ]; then			\
		$(RM) $(Document).lint;					\
		for f in $(DocumentSources); do				\
			echo -e "\n*** $$f ***" | tee --append $@;	\
			$(TEXTLINT) $$f | tee --append $@;		\
		done;							\
		touch .$(Document).lint;				\
	else								\
		$(MAKE) $(DocumentPDF);					\
		$(MAKE) $@;						\
	fi
endif

#
# Print make targets.
#
PhonyTargets += help
help:
	@echo "Targets:"
	@echo
	@echo "  make all       Compile $(DocumentPDF)"
	@echo "  make clean     Remove all build files"
if HAVE_PDF_VIEWER
	@echo "  make open      Open $(DocumentPDF) using $(PDF_VIEWER)"
endif
if HAVE_TEXCOUNT
	@echo "  make wc        Display the document word count"
endif
if HAVE_CHECKCITES
	@echo "  make cite      Check citations"
endif
if HAVE_TEXTLINT
	@echo "  make style     Check writing style"
endif

#------------------------------------------------------------------------
# Compiling PDF LaTeX documents.
#------------------------------------------------------------------------
$(DocumentPDF): $(DocumentDependencies)

# Compile commands. Since most *tex programs are noisy, we pipe the
# output to /dev/null to silence them. If there is an error, we re-run
# the command without the pipe so as to print the failure messages.
#   $@ Paths to .tex files
define pdflatex
	(echo -e "\nCOMMAND: $(PDFLATEX) $(CFLAGS) $1\n" >>$(DocumentBuildLog); \
	 $(PDFLATEX) $(CFLAGS) $1 2>&1 >>$(DocumentBuildLog) || $(PDFLATEX) $(CFLAGS) $1)
endef

# Invoke bibtex on a document.
#   $1 Name of document
define bibtex
	(echo -e "\nCOMMAND: $(BIBTEX) $1\n" >>$(DocumentBuildLog);	\
	 $(BIBTEX) $1 2>&1 >>$(DocumentBuildLog) || $(BIBTEX) $1)
endef

# Invoke bibtool to generate a bibliography from a .aux file.
#   $1 Path to auxfile
#   $2 Path to bibliography file to generate
define bibtool
	(echo -e "\nCOMMAND: $(BIBTOOL) -x $1 -o $2\n" >>$(DocumentBuildLog); \
	 $(BIBTOOL) -v -x $1 -o $2 &>>$(DocumentBuildLog) || $(BIBTOOL) -v -x $1 -o $2)
endef

# The LaTeX build target. This gnarly bit of shell hackery uses nested
# conditionals and sub-shells to invoke pdflatex, bibtex, bibtool, and
# cleanbib the correct number of times depending on the document
# contents. The sequence of program invocations is as follows:
#
# 1. pdflatex
# -  If the document contains citations:
# 2.     bibtex
# -      If the document uses the global biblibrary:
# 3.          bibtool
# 4.          cleanbib
# 5.     pdflatex
# 6.  pdflatex
%.pdf: %.tex
	$(AM_V_at)echo -e "Build log for `date`\n" >$(DocumentBuildLog)
	@if ! $(AM_V_P); then echo '  LATEX    $@'; fi
	$(AM_V_at)$(call pdflatex, $<)
if HAVE_BIBTEX
if HAVE_BIBTOOL
	$(AM_V_at)($(EGREP) '\\citation' >/dev/null 2>&1 < $*.aux && {	\
			if ! $(AM_V_P); then echo "  BIBTEX   $@"; fi;	\
			$(call bibtex, $*);				\
			$(EGREP) '\\bibdata.*$(BIBLIBRARY)' $*.aux >/dev/null 2>&1 && { \
				if ! $(AM_V_P); then echo '  BIBTOOL  $(DocumentBibfile)'; fi; \
				$(call bibtool,$*.aux,$(DocumentBibfile)); \
			} || true;					\
			if ! $(AM_V_P); then echo '  LATEX    $@'; fi;	\
			$(call pdflatex, $<);				\
		} || true)
else
	$(AM_V_at)($(EGREP) '\\citation' >/dev/null 2>&1 < $*.aux && {	\
			if ! $(AM_V_P); then echo "  BIBTEX   $@"; fi;	\
			$(call bibtex, $*);				\
			if ! $(AM_V_P); then echo '  LATEX    $@'; fi;	\
			$(call pdflatex, $<);				\
		} || true)
endif
endif
	@if ! $(AM_V_P); then echo '  LATEX    $@'; fi
	$(AM_V_at)$(call pdflatex, $<)
